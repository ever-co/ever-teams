import { observer } from 'mobx-react-lite';
import React, { FC, useEffect, useMemo } from 'react';
import {
	AccessibilityProps,
	ActivityIndicator,
	FlatList,
	Image,
	ImageStyle,
	Platform,
	StyleSheet,
	TextStyle,
	View,
	ViewStyle
} from 'react-native';
import Animated, {
	AnimatedStyleProp,
	Extrapolate,
	interpolate,
	useAnimatedStyle,
	useSharedValue,
	withSpring
} from 'react-native-reanimated';
import { Button, Card, EmptyState, Icon, Screen, Text, Toggle } from '../components';
import { isRTL, translate } from '../i18n';
import { useStores } from '../models';
import { Episode } from '../models/episode';
import { DemoTabScreenProps } from '../navigators/demo-navigator';
import { colors, spacing } from '../theme';
import { delay } from '../utils/delay';
import { openLinkInBrowser } from '../utils/open-link-in-browser';

const ICON_SIZE = 14;

const rnrImage1 = require('../../assets/images/rnr-image-1.png');
const rnrImage2 = require('../../assets/images/rnr-image-2.png');
const rnrImage3 = require('../../assets/images/rnr-image-3.png');
const rnrImages = [rnrImage1, rnrImage2, rnrImage3];

export const DemoPodcastListScreen: FC<DemoTabScreenProps<'DemoPodcastList'>> = observer(
	function DemoPodcastListScreen(_props) {
		const { episodeStore } = useStores();

		const [refreshing, setRefreshing] = React.useState(false);
		const [isLoading, setIsLoading] = React.useState(false);

		// initially, kick off a background refresh without the refreshing UI
		useEffect(() => {
			(async function load() {
				setIsLoading(true);
				await episodeStore.fetchEpisodes();
				setIsLoading(false);
			})();
		}, [episodeStore]);

		// simulate a longer refresh, if the refresh is too fast for UX
		async function manualRefresh() {
			setRefreshing(true);
			await Promise.all([episodeStore.fetchEpisodes(), delay(750)]);
			setRefreshing(false);
		}

		return (
			<Screen preset="fixed" safeAreaEdges={['top']} contentContainerStyle={$screenContentContainer}>
				<FlatList<Episode>
					data={episodeStore.episodesForList}
					extraData={episodeStore.favorites.length + episodeStore.episodes.length}
					contentContainerStyle={$flatListContentContainer}
					refreshing={refreshing}
					onRefresh={manualRefresh}
					ListEmptyComponent={
						isLoading ? (
							<ActivityIndicator />
						) : (
							<EmptyState
								preset="generic"
								style={$emptyState}
								headingTx={
									episodeStore.favoritesOnly
										? 'demoPodcastListScreen.noFavoritesEmptyState.heading'
										: undefined
								}
								contentTx={
									episodeStore.favoritesOnly
										? 'demoPodcastListScreen.noFavoritesEmptyState.content'
										: undefined
								}
								button={episodeStore.favoritesOnly ? null : undefined}
								buttonOnPress={manualRefresh}
								imageStyle={$emptyStateImage}
								ImageProps={{ resizeMode: 'contain' }}
							/>
						)
					}
					ListHeaderComponent={
						<View style={$heading}>
							<Text preset="heading" tx="demoPodcastListScreen.title" />
							{(episodeStore.favoritesOnly || episodeStore.episodesForList.length > 0) && (
								<View style={$toggle}>
									<Toggle
										value={episodeStore.favoritesOnly}
										onValueChange={() =>
											episodeStore.setProp('favoritesOnly', !episodeStore.favoritesOnly)
										}
										variant="switch"
										labelTx="demoPodcastListScreen.onlyFavorites"
										labelPosition="left"
										labelStyle={$labelStyle}
										accessibilityLabel={translate('demoPodcastListScreen.accessibility.switch')}
									/>
								</View>
							)}
						</View>
					}
					renderItem={({ item }) => (
						<EpisodeCard
							key={item.guid}
							episode={item}
							isFavorite={episodeStore.hasFavorite(item)}
							onPressFavorite={() => episodeStore.toggleFavorite(item)}
						/>
					)}
				/>
			</Screen>
		);
	}
);

const EpisodeCard = observer(function EpisodeCard({
	episode,
	isFavorite,
	onPressFavorite
}: {
	episode: Episode;
	onPressFavorite: () => void;
	isFavorite: boolean;
}) {
	const liked = useSharedValue(isFavorite ? 1 : 0);

	const imageUri = useMemo(() => {
		return rnrImages[Math.floor(Math.random() * rnrImages.length)];
	}, []);

	// Grey heart
	const animatedLikeButtonStyles = useAnimatedStyle(() => {
		return {
			transform: [
				{
					scale: interpolate(liked.value, [0, 1], [1, 0], Extrapolate.EXTEND)
				}
			],
			opacity: interpolate(liked.value, [0, 1], [1, 0], Extrapolate.CLAMP)
		} as any;
	});

	// Pink heart
	const animatedUnlikeButtonStyles = useAnimatedStyle(() => {
		return {
			transform: [
				{
					scale: liked.value
				}
			],
			opacity: liked.value
		} as any;
	});

	/**
	 * Android has a "longpress" accessibility action. iOS does not, so we just have to use a hint.
	 * @see https://reactnative.dev/docs/accessibility#accessibilityactions
	 */
	const accessibilityHintProps = useMemo(
		() =>
			Platform.select<AccessibilityProps>({
				ios: {
					accessibilityHint: translate('demoPodcastListScreen.accessibility.cardHint', {
						action: isFavorite ? 'unfavorite' : 'favorite'
					})
				},
				android: {
					accessibilityLabel: episode.title,
					accessibilityActions: [
						{
							name: 'longpress',
							label: translate('demoPodcastListScreen.accessibility.favoriteAction')
						}
					],
					onAccessibilityAction: ({ nativeEvent }) => {
						if (nativeEvent.actionName === 'longpress') {
							handlePressFavorite();
						}
					}
				}
			}),
		[episode, isFavorite]
	);

	const handlePressFavorite = () => {
		onPressFavorite();
		liked.value = withSpring(liked.value ? 0 : 1);
	};

	const handlePressCard = () => {
		openLinkInBrowser(episode.enclosure.link);
	};

	const ButtonLeftAccessory = useMemo(
		() =>
			function ButtonLeftAccessory() {
				return (
					<View>
						<Animated.View
							style={
								[
									$iconContainer,
									StyleSheet.absoluteFill,
									animatedLikeButtonStyles
								] as AnimatedStyleProp<ViewStyle | TextStyle | ImageStyle>
							}
						>
							<Icon
								icon="heart"
								size={ICON_SIZE}
								color={colors.palette.neutral800} // dark grey
							/>
						</Animated.View>
						<Animated.View
							style={
								[$iconContainer, animatedUnlikeButtonStyles] as AnimatedStyleProp<
									ViewStyle | TextStyle | ImageStyle
								>
							}
						>
							<Icon
								icon="heart"
								size={ICON_SIZE}
								color={colors.palette.primary400} // pink
							/>
						</Animated.View>
					</View>
				);
			},
		[]
	);

	return (
		<Card
			style={$item}
			verticalAlignment="force-footer-bottom"
			onPress={handlePressCard}
			onLongPress={handlePressFavorite}
			HeadingComponent={
				<View style={$metadata}>
					<Text
						style={$metadataText}
						size="xxs"
						accessibilityLabel={episode.datePublished.accessibilityLabel}
					>
						{episode.datePublished.textLabel}
					</Text>
					<Text style={$metadataText} size="xxs" accessibilityLabel={episode.duration.accessibilityLabel}>
						{episode.duration.textLabel}
					</Text>
				</View>
			}
			content={`${episode.parsedTitleAndSubtitle.title} - ${episode.parsedTitleAndSubtitle.subtitle}`}
			{...accessibilityHintProps}
			RightComponent={<Image source={imageUri} style={$itemThumbnail} />}
			FooterComponent={
				<Button
					onPress={handlePressFavorite}
					onLongPress={handlePressFavorite}
					style={[$favoriteButton, isFavorite && $unFavoriteButton]}
					accessibilityLabel={
						isFavorite
							? translate('demoPodcastListScreen.accessibility.unfavoriteIcon')
							: translate('demoPodcastListScreen.accessibility.favoriteIcon')
					}
					LeftAccessory={ButtonLeftAccessory}
				>
					<Text
						size="xxs"
						accessibilityLabel={episode.duration.accessibilityLabel}
						weight="medium"
						text={
							isFavorite
								? translate('demoPodcastListScreen.unfavoriteButton')
								: translate('demoPodcastListScreen.favoriteButton')
						}
					/>
				</Button>
			}
		/>
	);
});

// #region Styles
const $screenContentContainer: ViewStyle = {
	flex: 1
};

const $flatListContentContainer: ViewStyle = {
	paddingHorizontal: spacing.large,
	paddingTop: spacing.large + spacing.extraLarge,
	paddingBottom: spacing.large
};

const $heading: ViewStyle = {
	marginBottom: spacing.medium
};

const $item: ViewStyle = {
	padding: spacing.medium,
	marginTop: spacing.medium,
	minHeight: 120
};

const $itemThumbnail: ImageStyle = {
	marginTop: spacing.small,
	borderRadius: 50,
	alignSelf: 'flex-start'
};

const $toggle: ViewStyle = {
	marginTop: spacing.medium
};

const $labelStyle: TextStyle = {
	textAlign: 'left'
};

const $iconContainer: ViewStyle = {
	height: ICON_SIZE,
	width: ICON_SIZE,
	flexDirection: 'row',
	marginRight: spacing.small
};

const $metadata: TextStyle = {
	color: colors.textDim,
	marginTop: spacing.extraSmall,
	flexDirection: 'row'
};

const $metadataText: TextStyle = {
	color: colors.textDim,
	marginRight: spacing.medium,
	marginBottom: spacing.extraSmall
};

const $favoriteButton: ViewStyle = {
	borderRadius: 17,
	marginTop: spacing.medium,
	justifyContent: 'flex-start',
	backgroundColor: colors.palette.neutral300,
	borderColor: colors.palette.neutral300,
	paddingHorizontal: spacing.medium,
	paddingTop: spacing.micro,
	paddingBottom: 0,
	minHeight: 32,
	alignSelf: 'flex-start'
};

const $unFavoriteButton: ViewStyle = {
	borderColor: colors.palette.primary100,
	backgroundColor: colors.palette.primary100
};

const $emptyState: ViewStyle = {
	marginTop: spacing.huge
};

const $emptyStateImage: ImageStyle = {
	transform: [{ scaleX: isRTL ? -1 : 1 }]
};
// #endregion

// @demo remove-file
